// Code generated by goa v3.4.3, DO NOT EDIT.
//
// v1/wallet HTTP client CLI support package
//
// Command:
// $ goa gen github.com/jainpiyush19/cryptowallet/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	v1wallet "github.com/jainpiyush19/cryptowallet/gen/v1_wallet"
	goa "goa.design/goa/v3/pkg"
)

// BuildDepositPayload builds the payload for the v1/wallet deposit endpoint
// from CLI flags.
func BuildDepositPayload(v1WalletDepositBody string, v1WalletDepositToken string) (*v1wallet.DepositRequestBody, error) {
	var err error
	var body DepositRequestBody
	{
		err = json.Unmarshal([]byte(v1WalletDepositBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"amount\": 0.7821871049830849\n   }'")
		}
		if body.Amount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.amount", body.Amount, 0, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if v1WalletDepositToken != "" {
			token = &v1WalletDepositToken
		}
	}
	v := &v1wallet.DepositRequestBody{
		Amount: body.Amount,
	}
	v.Token = token

	return v, nil
}

// BuildWithdrawPayload builds the payload for the v1/wallet withdraw endpoint
// from CLI flags.
func BuildWithdrawPayload(v1WalletWithdrawBody string, v1WalletWithdrawToken string) (*v1wallet.WithdrawRequestBody, error) {
	var err error
	var body WithdrawRequestBody
	{
		err = json.Unmarshal([]byte(v1WalletWithdrawBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"amount\": 0.7427372802563682\n   }'")
		}
		if body.Amount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.amount", body.Amount, 0, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if v1WalletWithdrawToken != "" {
			token = &v1WalletWithdrawToken
		}
	}
	v := &v1wallet.WithdrawRequestBody{
		Amount: body.Amount,
	}
	v.Token = token

	return v, nil
}

// BuildTransferPayload builds the payload for the v1/wallet transfer endpoint
// from CLI flags.
func BuildTransferPayload(v1WalletTransferBody string, v1WalletTransferToken string) (*v1wallet.TransferRequestBody, error) {
	var err error
	var body TransferRequestBody
	{
		err = json.Unmarshal([]byte(v1WalletTransferBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"amount\": 0.3172865797517538,\n      \"receiverID\": 294003090530668039\n   }'")
		}
		if body.ReceiverID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.receiverID", body.ReceiverID, 0, true))
		}
		if body.Amount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.amount", body.Amount, 0, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if v1WalletTransferToken != "" {
			token = &v1WalletTransferToken
		}
	}
	v := &v1wallet.TransferRequestBody{
		ReceiverID: body.ReceiverID,
		Amount:     body.Amount,
	}
	v.Token = token

	return v, nil
}

// BuildBalancePayload builds the payload for the v1/wallet balance endpoint
// from CLI flags.
func BuildBalancePayload(v1WalletBalanceUserID string, v1WalletBalanceToken string) (*v1wallet.BalanceRequestBody, error) {
	var err error
	var userID int64
	{
		userID, err = strconv.ParseInt(v1WalletBalanceUserID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT64")
		}
		if userID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("userID", userID, 0, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if v1WalletBalanceToken != "" {
			token = &v1WalletBalanceToken
		}
	}
	v := &v1wallet.BalanceRequestBody{}
	v.UserID = userID
	v.Token = token

	return v, nil
}

// BuildAdminWalletsPayload builds the payload for the v1/wallet admin/wallets
// endpoint from CLI flags.
func BuildAdminWalletsPayload(v1WalletAdminWalletsToken string) (*v1wallet.AdminWalletRequestBody, error) {
	var token *string
	{
		if v1WalletAdminWalletsToken != "" {
			token = &v1WalletAdminWalletsToken
		}
	}
	v := &v1wallet.AdminWalletRequestBody{}
	v.Token = token

	return v, nil
}
